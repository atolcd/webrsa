<?php
	/**
	 * Code source de la classe DefaultPaginatorHelper.
	 *
	 * PHP 5.4
	 *
	 * @package Default
	 * @subpackage View.Helper
	 * @license CeCiLL V2 (http://www.cecill.info/licences/Licence_CeCILL_V2-fr.html)
	 */
	App::uses( 'PaginatorHelper', 'View/Helper' );

	/**
	 * La classe DefaultPaginatorHelper étend la classe PaginatorHelper de CakePHP
	 * dans le cadre de son utilisation dans le plugin Default.
	 *
	 * @package Default
	 * @subpackage View.Helper
	 */
	class DefaultPaginatorHelper extends PaginatorHelper
	{
		/**
		 * Override PaginatorHelper::sort()
		 * 
		 * Generates a sorting link. Sets named parameters for the sort and direction.  Handles
		 * direction switching automatically.
		 *
		 * ### Options:
		 *
		 * - `escape` Whether you want the contents html entity encoded, defaults to true
		 * - `model` The model to use, defaults to PaginatorHelper::defaultModel()
		 * - `direction` The default direction to use when this link isn't active.
		 *
		 * @param string $key The name of the key that the recordset should be sorted.
		 * @param string $title Title for the link. If $title is null $key will be used
		 *		for the title and will be generated by inflection.
		 * @param array $options Options for sorting link. See above for list of keys.
		 * @return string A link sorting default by 'asc'. If the resultset is sorted 'asc' by the specified
		 *  key the returned link will sort by 'desc'.
		 * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/paginator.html#PaginatorHelper::sort
		 */
		public function sort($key, $title = null, $options = array()) {
			if (!Configure::read('ConfigurableQuery.common.two_ways_order.enabled')) {
				$return = parent::sort($key, $title, $options);
			} else {
				
				$options = array_merge(array('url' => array(), 'model' => null), $options);
				$url = $options['url'];
				unset($options['url']);

				if (empty($title)) {
					$title = $key;
					$title = __(Inflector::humanize(preg_replace('/_id$/', '', $title)));
				}
				$dir = isset($options['direction']) ? $options['direction'] : 'asc';
				unset($options['direction']);

				$sortKey = $this->sortKey($options['model']);
				$defaultModel = $this->defaultModel();
				$isSorted = (
					$sortKey === $key ||
					$sortKey === $defaultModel . '.' . $key ||
					$key === $defaultModel . '.' . $sortKey
				);

				$ascClass = "img-asc";
				$descClass = "img-desc";

				if ($isSorted) {
					$dir = $this->sortDir($options['model']) === 'asc' ? 'desc' : 'asc';
					$class = $dir === 'asc' ? 'desc' : 'asc';
					if (!empty($options['class'])) {
						$options['class'] .= ' ' . $class;
					} else {
						$options['class'] = $class;
					}

					${$class."Class"} .= ' active';
				}

				if (is_array($title) && array_key_exists($dir, $title)) {
					$title = $title[$dir];
				}

				$asc = array_merge(array('sort' => $key, 'direction' => 'asc'), $url, array('order' => null));
				$desc = array_merge(array('sort' => $key, 'direction' => 'desc'), $url, array('order' => null));

				$ascImg = '<div class="'.$ascClass.'" title="Ranger par ordre croissant"></div>';
				$descImg = '<div class="'.$descClass.'" title="Ranger par ordre décroissant"></div>';

				$options['escape'] = false;
				$options['class'] = trim((string)Hash::get($options, 'class').' two_ways');
				
				$url = array_merge(array('sort' => $key, 'direction' => $dir), $url, array('order' => null));
				
				$ascLink = $this->link($ascImg, $asc,
					array('class' => 'arrow arrow-up', 'title' => 'Ranger par ordre croissant') + $options
				);
				$descLink = $this->link($descImg, $desc,
					array('class' => 'arrow arrow-down', 'title' => 'Ranger par ordre décroissant') + $options
				);
				
				$options['title'] = $dir === 'asc' ? 'Ranger par ordre croissant' : 'Ranger par ordre décroissant';
				
				$return = '<div class="two_ways order-container">'.$this->link($title, $url, $options)
					.' <div class="container two_ways">'
					.$ascLink
					.$descLink
					.'</div></div>';
			}
			
			return $return;
		}
	}
?>